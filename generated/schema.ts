// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Bought extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Bought entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Bought must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Bought", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Bought | null {
    return changetype<Bought | null>(store.get("Bought", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get tokens(): BigInt {
    let value = this.get("tokens");
    return value!.toBigInt();
  }

  set tokens(value: BigInt) {
    this.set("tokens", Value.fromBigInt(value));
  }

  get beans(): BigInt {
    let value = this.get("beans");
    return value!.toBigInt();
  }

  set beans(value: BigInt) {
    this.set("beans", Value.fromBigInt(value));
  }

  get dollarBuy(): BigInt {
    let value = this.get("dollarBuy");
    return value!.toBigInt();
  }

  set dollarBuy(value: BigInt) {
    this.set("dollarBuy", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Sold extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Sold entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Sold must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Sold", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Sold | null {
    return changetype<Sold | null>(store.get("Sold", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get tokens(): BigInt {
    let value = this.get("tokens");
    return value!.toBigInt();
  }

  set tokens(value: BigInt) {
    this.set("tokens", Value.fromBigInt(value));
  }

  get beans(): BigInt {
    let value = this.get("beans");
    return value!.toBigInt();
  }

  set beans(value: BigInt) {
    this.set("beans", Value.fromBigInt(value));
  }

  get dollarSell(): BigInt {
    let value = this.get("dollarSell");
    return value!.toBigInt();
  }

  set dollarSell(value: BigInt) {
    this.set("dollarSell", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Transfer extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Transfer must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Transfer", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Transfer | null {
    return changetype<Transfer | null>(store.get("Transfer", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Surgeswap extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Surgeswap entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Surgeswap must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Surgeswap", id.toString(), this);
    }
  }

  static load(id: string): Surgeswap | null {
    return changetype<Surgeswap | null>(store.get("Surgeswap", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pairCount(): i32 {
    let value = this.get("pairCount");
    return value!.toI32();
  }

  set pairCount(value: i32) {
    this.set("pairCount", Value.fromI32(value));
  }

  get totalVolumeUSD(): BigDecimal {
    let value = this.get("totalVolumeUSD");
    return value!.toBigDecimal();
  }

  set totalVolumeUSD(value: BigDecimal) {
    this.set("totalVolumeUSD", Value.fromBigDecimal(value));
  }

  get totalLiquidityUSD(): BigDecimal {
    let value = this.get("totalLiquidityUSD");
    return value!.toBigDecimal();
  }

  set totalLiquidityUSD(value: BigDecimal) {
    this.set("totalLiquidityUSD", Value.fromBigDecimal(value));
  }

  get totalLiquidityETH(): BigDecimal {
    let value = this.get("totalLiquidityETH");
    return value!.toBigDecimal();
  }

  set totalLiquidityETH(value: BigDecimal) {
    this.set("totalLiquidityETH", Value.fromBigDecimal(value));
  }

  get totalLiquiditySRG(): BigDecimal {
    let value = this.get("totalLiquiditySRG");
    return value!.toBigDecimal();
  }

  set totalLiquiditySRG(value: BigDecimal) {
    this.set("totalLiquiditySRG", Value.fromBigDecimal(value));
  }

  get txCount(): BigInt {
    let value = this.get("txCount");
    return value!.toBigInt();
  }

  set txCount(value: BigInt) {
    this.set("txCount", Value.fromBigInt(value));
  }
}

export class pair extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save pair entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type pair must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("pair", id.toString(), this);
    }
  }

  static load(id: string): pair | null {
    return changetype<pair | null>(store.get("pair", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get base(): string {
    let value = this.get("base");
    return value!.toString();
  }

  set base(value: string) {
    this.set("base", Value.fromString(value));
  }

  get target(): string {
    let value = this.get("target");
    return value!.toString();
  }

  set target(value: string) {
    this.set("target", Value.fromString(value));
  }

  get pool_id(): string {
    let value = this.get("pool_id");
    return value!.toString();
  }

  set pool_id(value: string) {
    this.set("pool_id", Value.fromString(value));
  }
}

export class ticker extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ticker entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ticker must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ticker", id.toString(), this);
    }
  }

  static load(id: string): ticker | null {
    return changetype<ticker | null>(store.get("ticker", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get base_currency(): string {
    let value = this.get("base_currency");
    return value!.toString();
  }

  set base_currency(value: string) {
    this.set("base_currency", Value.fromString(value));
  }

  get target_currency(): string {
    let value = this.get("target_currency");
    return value!.toString();
  }

  set target_currency(value: string) {
    this.set("target_currency", Value.fromString(value));
  }

  get last_price(): BigDecimal {
    let value = this.get("last_price");
    return value!.toBigDecimal();
  }

  set last_price(value: BigDecimal) {
    this.set("last_price", Value.fromBigDecimal(value));
  }

  get base_volume(): BigDecimal {
    let value = this.get("base_volume");
    return value!.toBigDecimal();
  }

  set base_volume(value: BigDecimal) {
    this.set("base_volume", Value.fromBigDecimal(value));
  }

  get target_volume(): BigDecimal {
    let value = this.get("target_volume");
    return value!.toBigDecimal();
  }

  set target_volume(value: BigDecimal) {
    this.set("target_volume", Value.fromBigDecimal(value));
  }

  get pool_id(): string {
    let value = this.get("pool_id");
    return value!.toString();
  }

  set pool_id(value: string) {
    this.set("pool_id", Value.fromString(value));
  }

  get liquidity_in_usd(): BigDecimal {
    let value = this.get("liquidity_in_usd");
    return value!.toBigDecimal();
  }

  set liquidity_in_usd(value: BigDecimal) {
    this.set("liquidity_in_usd", Value.fromBigDecimal(value));
  }
}
